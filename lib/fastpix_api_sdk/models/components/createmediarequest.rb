# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module FastpixApiSDK
  module Models
    module Components
    

      class CreateMediaRequest
        extend T::Sig
        include Crystalline::MetadataFields


        field :inputs, T::Array[T.any(Models::Components::VideoInput, Models::Components::WatermarkInput, Models::Components::AudioInput, Models::Components::SubtitleInput)], { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('inputs'), required: true } }
        # Determines whether access to the streamed content is kept private or available to all.
        # 
        field :access_policy, Models::Components::CreateMediaRequestAccessPolicy, { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('accessPolicy'), required: true, 'decoder': Utils.enum_from_string(Models::Components::CreateMediaRequestAccessPolicy, false) } }
        # You can search for videos with specific key-value pairs using metadata, when you tag a video in "key" : "value" pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have a maximum of 255 characters and up to 10 entries are allowed.
        # 
        field :metadata, T.nilable(Models::Components::CreateMediaRequestMetadata), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('metadata') } }
        # Generates subtitle files for audio/video files.
        # 
        field :subtitle, T.nilable(Models::Components::Subtitle), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('subtitle') } }
        # â€œcapped_4k": Generates an mp4 video file up to 4k resolution "audioOnly": Generates an m4a audio file of the media file "audioOnly,capped_4k": Generates both video and audio media files for offline viewing
        # 
        field :mp4_support, T.nilable(Models::Components::CreateMediaRequestMp4Support), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('mp4Support'), 'decoder': Utils.enum_from_string(Models::Components::CreateMediaRequestMp4Support, true) } }
        # The sourceAccess parameter determines whether the original media file is accessible. Set to true to enable access or false to restrict it
        field :source_access, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('sourceAccess') } }

        field :summary, T.nilable(Models::Components::Summary), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('summary') } }
        # Enable or disable the chapters feature for the media. Set to `true` to enable chapters or `false` to disable.
        # 
        field :chapters, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('chapters') } }
        # Enable or disable named entity extraction. Set to `true` to enable or `false` to disable.
        # 
        field :named_entities, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('namedEntities') } }

        field :moderation, T.nilable(Models::Components::Moderation), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('moderation') } }

        field :access_restrictions, T.nilable(Models::Components::CreateMediaRequestAccessRestrictions), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('accessRestrictions') } }
        # normalize volume of the audio track. This is available for pre-recorded content only.
        # 
        field :optimize_audio, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('optimizeAudio') } }
        # The maximum resolution tier determines the highest quality your media will be available in.
        # 
        field :max_resolution, T.nilable(Models::Components::CreateMediaRequestMaxResolution), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('maxResolution'), 'decoder': Utils.enum_from_string(Models::Components::CreateMediaRequestMaxResolution, true) } }

        sig { params(inputs: T::Array[T.any(Models::Components::VideoInput, Models::Components::WatermarkInput, Models::Components::AudioInput, Models::Components::SubtitleInput)], access_policy: Models::Components::CreateMediaRequestAccessPolicy, metadata: T.nilable(Models::Components::CreateMediaRequestMetadata), subtitle: T.nilable(Models::Components::Subtitle), mp4_support: T.nilable(Models::Components::CreateMediaRequestMp4Support), source_access: T.nilable(T::Boolean), summary: T.nilable(Models::Components::Summary), chapters: T.nilable(T::Boolean), named_entities: T.nilable(T::Boolean), moderation: T.nilable(Models::Components::Moderation), access_restrictions: T.nilable(Models::Components::CreateMediaRequestAccessRestrictions), optimize_audio: T.nilable(T::Boolean), max_resolution: T.nilable(Models::Components::CreateMediaRequestMaxResolution)).void }
        def initialize(inputs:, access_policy:, metadata: nil, subtitle: nil, mp4_support: nil, source_access: nil, summary: nil, chapters: nil, named_entities: nil, moderation: nil, access_restrictions: nil, optimize_audio: false, max_resolution: Models::Components::CreateMediaRequestMaxResolution::ONE_THOUSAND_AND_EIGHTYP)
          @inputs = inputs
          @access_policy = access_policy
          @metadata = metadata
          @subtitle = subtitle
          @mp4_support = mp4_support
          @source_access = source_access
          @summary = summary
          @chapters = chapters
          @named_entities = named_entities
          @moderation = moderation
          @access_restrictions = access_restrictions
          @optimize_audio = optimize_audio
          @max_resolution = max_resolution
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @inputs == other.inputs
          return false unless @access_policy == other.access_policy
          return false unless @metadata == other.metadata
          return false unless @subtitle == other.subtitle
          return false unless @mp4_support == other.mp4_support
          return false unless @source_access == other.source_access
          return false unless @summary == other.summary
          return false unless @chapters == other.chapters
          return false unless @named_entities == other.named_entities
          return false unless @moderation == other.moderation
          return false unless @access_restrictions == other.access_restrictions
          return false unless @optimize_audio == other.optimize_audio
          return false unless @max_resolution == other.max_resolution
          true
        end
      end
    end
  end
end
