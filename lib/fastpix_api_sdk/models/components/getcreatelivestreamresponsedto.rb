# Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

# typed: true
# frozen_string_literal: true


module FastpixApiSDK
  module Models
    module Components
    
      # Displays the result of the request.
      class GetCreateLiveStreamResponseDTO
        extend T::Sig
        include Crystalline::MetadataFields

        # Upon creating a new live stream, FastPix assigns a unique identifier to the stream.
        field :stream_id, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('streamId') } }
        # A unique stream key is generated for streaming, allowing the user to start streaming on any third-party platform using this key.
        field :stream_key, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('streamKey') } }
        # A secret used for securing the SRT stream. This ensures that only authorized users can access the stream.
        field :srt_secret, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('srtSecret') } }
        # FastPix allows for a to trial the live stream for free. The duration of trial streams is five minutes. After five minutes of activity, the trial stream is turned off, and the recorded asset is removed after a day.
        field :trial, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('trial') } }
        # The current live stream status can be one of four values:Idle, Preparing, Active or Disabled.The Idle status signifies that there isn't a broadcast in progress.The preparing status indicates that the stream is getting prepared. while, the Active status indicates that a broadcast is currently in progress. The Disabled status means that no more RTMP streams can be published.
        field :status, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('status') } }
        # Max resolution can be used to control the maximum resolution your media is encoded, stored, and streamed at.
        field :max_resolution, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('maxResolution') } }
        # The maximum duration in seconds that a live stream can have before it ends the stream.
        field :max_duration, T.nilable(::Integer), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('maxDuration') } }
        # It is the moment when the stream was created Time the media was generated, defined as a localDateTime (UTC Time).
        field :created_at, T.nilable(::DateTime), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('createdAt'), 'decoder': Utils.datetime_from_iso_format(true) } }
        # When set to true, the livestream will be recorded and stored for later viewing purposes. If set to false, the livestream will not be recorded.
        field :enable_recording, T.nilable(T::Boolean), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('enableRecording') } }
        # Determines whether the recorded stream should be publicly accessible or private in Live to VOD (Video on Demand).
        field :media_policy, T.nilable(::String), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('mediaPolicy') } }
        # You can search for videos with specific key value pairs using metadata, when you tag a video in "key":"value"s pairs. Dynamic Metadata allows you to define a key that allows any value pair. You can have maximum of 255 characters and upto 10 entries are allowed.
        field :metadata, T.nilable(Models::Components::GetCreateLiveStreamResponseDTOMetadata), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('metadata') } }
        # A collection of Playback ID objects utilized for crafting HLS playback urls.
        field :playback_id, T.nilable(T::Array[Models::Components::PlaybackIds]), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('playbackId') } }
        # This object contains the livestream playback response details for SRT Protocol.
        field :srt_playback_response, T.nilable(Models::Components::GetCreateLiveStreamResponseDTOSrtPlaybackResponse), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('srtPlaybackResponse') } }
        # In case the software streaming the live, get disrupted for any reason and get disconnect from FastPix, the reconnect window specifies the waiting time span of FastPix will wait before ending the stream. Before starting the stream, you can set the reconnect window time set which is up to 1800 seconds.
        field :reconnect_window, T.nilable(::Integer), { 'format_json': { 'letter_case': ::FastpixApiSDK::Utils.field_name('reconnectWindow') } }

        sig { params(stream_id: T.nilable(::String), stream_key: T.nilable(::String), srt_secret: T.nilable(::String), trial: T.nilable(T::Boolean), status: T.nilable(::String), max_resolution: T.nilable(::String), max_duration: T.nilable(::Integer), created_at: T.nilable(::DateTime), enable_recording: T.nilable(T::Boolean), media_policy: T.nilable(::String), metadata: T.nilable(Models::Components::GetCreateLiveStreamResponseDTOMetadata), playback_id: T.nilable(T::Array[Models::Components::PlaybackIds]), srt_playback_response: T.nilable(Models::Components::GetCreateLiveStreamResponseDTOSrtPlaybackResponse), reconnect_window: T.nilable(::Integer)).void }
        def initialize(stream_id: nil, stream_key: nil, srt_secret: nil, trial: nil, status: nil, max_resolution: nil, max_duration: nil, created_at: nil, enable_recording: nil, media_policy: nil, metadata: nil, playback_id: nil, srt_playback_response: nil, reconnect_window: 60)
          @stream_id = stream_id
          @stream_key = stream_key
          @srt_secret = srt_secret
          @trial = trial
          @status = status
          @max_resolution = max_resolution
          @max_duration = max_duration
          @created_at = created_at
          @enable_recording = enable_recording
          @media_policy = media_policy
          @metadata = metadata
          @playback_id = playback_id
          @srt_playback_response = srt_playback_response
          @reconnect_window = reconnect_window
        end

        sig { params(other: T.untyped).returns(T::Boolean) }
        def ==(other)
          return false unless other.is_a? self.class
          return false unless @stream_id == other.stream_id
          return false unless @stream_key == other.stream_key
          return false unless @srt_secret == other.srt_secret
          return false unless @trial == other.trial
          return false unless @status == other.status
          return false unless @max_resolution == other.max_resolution
          return false unless @max_duration == other.max_duration
          return false unless @created_at == other.created_at
          return false unless @enable_recording == other.enable_recording
          return false unless @media_policy == other.media_policy
          return false unless @metadata == other.metadata
          return false unless @playback_id == other.playback_id
          return false unless @srt_playback_response == other.srt_playback_response
          return false unless @reconnect_window == other.reconnect_window
          true
        end
      end
    end
  end
end
